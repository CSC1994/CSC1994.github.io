<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/f32.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/f16.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="python,排序算法,">










<meta name="description" content="这一部分我们对面试时涉及到的排序算法进行总结，主要包括插入排序、二分插入排序、希尔排序、选择排序、冒泡排序、鸡尾酒排序、快速排序、堆排序、归并排序、桶排序、计数排序和基数排序，不多说，下面进入主题。 一、插入排序1）算法简介 插入排序的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用O(1)额外空间">
<meta name="keywords" content="python,排序算法">
<meta property="og:type" content="article">
<meta property="og:title" content="经典排序算法总结">
<meta property="og:url" content="http://yoursite.com/2019/07/28/经典排序算法总结/index.html">
<meta property="og:site_name" content="咋家">
<meta property="og:description" content="这一部分我们对面试时涉及到的排序算法进行总结，主要包括插入排序、二分插入排序、希尔排序、选择排序、冒泡排序、鸡尾酒排序、快速排序、堆排序、归并排序、桶排序、计数排序和基数排序，不多说，下面进入主题。 一、插入排序1）算法简介 插入排序的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用O(1)额外空间">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005xDMfSly1g491vnwsy7j30bi06976v.jpg">
<meta property="og:updated_time" content="2019-07-28T01:38:19.035Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="经典排序算法总结">
<meta name="twitter:description" content="这一部分我们对面试时涉及到的排序算法进行总结，主要包括插入排序、二分插入排序、希尔排序、选择排序、冒泡排序、鸡尾酒排序、快速排序、堆排序、归并排序、桶排序、计数排序和基数排序，不多说，下面进入主题。 一、插入排序1）算法简介 插入排序的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用O(1)额外空间">
<meta name="twitter:image" content="http://ww1.sinaimg.cn/large/005xDMfSly1g491vnwsy7j30bi06976v.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/07/28/经典排序算法总结/">





  <title>经典排序算法总结 | 咋家</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">咋家</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/28/经典排序算法总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="廿十">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/author.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="咋家">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">经典排序算法总结</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-28T09:18:43+08:00">
                2019-07-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/面试/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>这一部分我们对面试时涉及到的排序算法进行总结，主要包括<strong>插入排序、二分插入排序、希尔排序、选择排序、冒泡排序、鸡尾酒排序、快速排序、堆排序、归并排序、桶排序、计数排序和基数排序</strong>，不多说，下面进入主题。</p>
<h5 id="一、插入排序"><a href="#一、插入排序" class="headerlink" title="一、插入排序"></a>一、插入排序</h5><p><strong>1）算法简介</strong></p>
<p>插入排序的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用O(1)额外空间的排序），因而在从后往前扫描过程中，需要反复把已排序元素逐步向后挪位，为新元素提供插入空间。</p>
<p><strong>2）算法描述</strong></p>
<p>一般来说，插入排序都采用in-place在数组上实现，具体算法描述如下：</p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果该元素（已排序）大于新元素，将该元素移动下一位置</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤2~5</li>
</ol>
<p>如果目标是把n个元素的序列升序排列，那么采用插入排序存在最好情况和最坏情况。最好情况是，序列已经是升序排列了，在这种情况下，需要进行的比较操作需(n-1)次即可。最坏情况就是，序列是降序排列，那么此时需要进行的比较共有n(n-1)/2次。插入排序的赋值操作是比较操作的次数减去(n-1)次。平均来说插入排序算法复杂度为O(n^2)。因而，插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，例如，量级小于千，那么插入排序还是一个不错的选择。</p>
<p><strong>3）算法代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    n =len(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        temp =nums[i]</span><br><span class="line">        j =i<span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> j &gt;=<span class="number">0</span> <span class="keyword">and</span> nums[j] &gt;temp:</span><br><span class="line">            nums[j+<span class="number">1</span>] =nums[j]</span><br><span class="line">            j -=<span class="number">1</span></span><br><span class="line">        nums[j+<span class="number">1</span>] =temp</span><br><span class="line">     <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>

<h5 id="二、二分插入排序"><a href="#二、二分插入排序" class="headerlink" title="二、二分插入排序"></a>二、二分插入排序</h5><p><strong>1）算法简介</strong></p>
<p>二分插入排序是一种在直接插入排序算法上进行小改动的排序算法，其与直接排序算法最大的区别在于查找插入位置时使用的是二分查找的方式，在速度上有一定提升。</p>
<p><strong>2）算法描述</strong></p>
<p>一般来说，插入排序都采用in-place在数组上实现，具体算法如下：</p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中二分查找到第一个比它大的数的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复上述两步</li>
</ol>
<p>稳定、空间代价：O(1)、时间代价：插入每个记录需要O(log i)比较，最多移动i+1次，最少2次，最佳情况O(nlogn)，最差和平均情况O(n^2)。</p>
<p>二分插入排序是一种稳定的排序。当n较大时，总排序比较次数比直接插入排序的最差情况好得多，但比最好情况差，当元素初始序列接近有序时，直接插入排序比二分插入排序比较次数少。二分插入排序元素移动次数与直接插入排序相同，依赖于元素初始序列。</p>
<p><strong>3）算法代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BinInsert_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    </span><br><span class="line">    n =len(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        key =nums[i]</span><br><span class="line">        left =<span class="number">0</span></span><br><span class="line">        right =i<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;=right:</span><br><span class="line">            middle =(left +right)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[middle] &gt;key:</span><br><span class="line">                right =middle<span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left =middle+<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i<span class="number">-1</span>, left<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            nums[j+<span class="number">1</span>] =nums[j]</span><br><span class="line">        nums[left] =key</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>

<h5 id="三、希尔排序"><a href="#三、希尔排序" class="headerlink" title="三、希尔排序"></a>三、希尔排序</h5><p><strong>1）算法简介</strong></p>
<p>希尔排序，也称递减增量排序算法，因DL.Shell于1959年提出而得名，是插入排序的一种高效的改进版本，但其是非稳定排序算法。</p>
<p><strong>2）算法描述</strong></p>
<ol>
<li>先取一个小于n的整数d1作为第一个增量，把文件的全部记录分成d1个组</li>
<li>所有距离为d1的倍数的记录放在同一个组中，在各组内进行直接插入排序</li>
<li>取第二个增量d2&lt;d1重复上述的分组和排序</li>
<li>直至所取的增量dt=1(dt&lt;dt-1&lt;……&lt;d2&lt;d1)，即所有记录放在同一组中进行直接插入排序为止</li>
</ol>
<p>希尔排序的时间复杂度与增量序列的选取有关，例如希尔增量时间复杂度为O(n^2)，而Hibbard增量的希尔排序的时间复杂度为O(n^(5/4))，但是至今仍然没有人能找出希尔排序的精确下界。</p>
<p><strong>3）算法代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ShellSort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    n =len(nums)</span><br><span class="line">    h =<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> h&lt;n//<span class="number">3</span>:</span><br><span class="line">        h =<span class="number">3</span>*h+<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> h&gt;=<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(h, n):</span><br><span class="line">            j =i-h</span><br><span class="line">            temp =nums[i]</span><br><span class="line">            <span class="keyword">while</span> j&gt;=<span class="number">0</span> <span class="keyword">and</span> nums[j]&gt;temp:</span><br><span class="line">                nums[j+h] =nums[j]</span><br><span class="line">                j -=h</span><br><span class="line">            nums[j+h] =temp</span><br><span class="line">        h =h//<span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>

<h5 id="四、选择排序"><a href="#四、选择排序" class="headerlink" title="四、选择排序"></a>四、选择排序</h5><p><strong>1）算法简介</strong></p>
<p>选择排序是一种简单直观的排序算法，原理如下：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾，以此类推，直到所有元素均排序完毕。</p>
<p><strong>2）算法描述</strong></p>
<p>n个记录的文件的直接选择排序可经过n-1趟直接选择排序得到有序结果：</p>
<ol>
<li>初始状态：无序区为R[1…n]，有序区为空</li>
<li>第i趟排序（i=1, 2,…,n-1）：第i趟排序开始时，当前有序区和无序区分别为R[1…i-1]和R[i…n]。该趟排序从当前无序区中选出关键字最小的记录R[k]，将它与无序区的第1个记录R交换，使R[1…i]和R分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区</li>
<li>前n-1趟结束，数组有序化了</li>
</ol>
<p>选择排序的交换操作介于0和(n-1)次之间。选择排序的比较操作为n(n-1)/2次之间。选择排序的赋值操作介于0和3(n-1)次之间。比较次数与关键字的初始状态无关，总的比较次数N=(n-1)+(n-2)+…+1=n*(n-1)/2，交换次数O(n)，最好情况是已经有序，交换0次；最坏情况是逆序，交换n-1次。交换次数比冒泡排序少多了，由于交换所需CPU时间比比较所需的CPU时间多，n值较小时，选择排序比冒泡排序快。</p>
<table>
<thead>
<tr>
<th>最差时间复杂度</th>
<th>O(n^2)</th>
</tr>
</thead>
<tbody><tr>
<td>最优时间复杂度</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>平均时间复杂度</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>最差空间复杂度</td>
<td>O(n)  total, O(1)</td>
</tr>
</tbody></table>
<p><strong>3）算法代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SelectionSort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    n =len(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        min =i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> nums[min] &gt;nums[j]:</span><br><span class="line">                min =j</span><br><span class="line">        <span class="keyword">if</span> min != i:</span><br><span class="line">            nums[min], nums[i] =nums[i], nums[min]</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>

<h5 id="五、冒泡排序"><a href="#五、冒泡排序" class="headerlink" title="五、冒泡排序"></a>五、冒泡排序</h5><p><strong>1）算法简介</strong></p>
<p>冒泡排序是一种简单的排序算法。它重复的走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来，走访数列的工作是重复的进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<p><strong>2）算法描述</strong></p>
<ol>
<li>比较相邻的元素，如果第一个比第二个大，就交换他们两个</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数</li>
<li>针对所有的元素重复以上的步骤，除了最后一个</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较</li>
</ol>
<p>冒泡排序是与插入排序拥有相等的执行时间，但是两种方法在需要的交换次数却很大的不同。在最坏的情况，冒泡排序需要O(n^2)次交换，而插入排序只需要最多O(n)次交换。冒泡排序的实现通常会对已经排序好的数列拙劣的执行O(n^2)，而插入排序只需要O(n)个运算。因此很多现代的算法教科书避免使用冒泡排序，而用插入排序取代。冒泡排序如果能在内部循环第一次执行时，使用一个旗标来表示有无需要交换的可能，也有可能把最好的复杂度降低到O(n)。在这种情况下，在已经排序好的数列就无交换的需要。若在每次走访数列时，把走访顺序和比较大小反过来，也可以稍微的改进效率，有时候称为往返排序，因为算法会从数列的一端到另一端之间穿梭往返。</p>
<table>
<thead>
<tr>
<th>最差时间复杂度</th>
<th>O(n^2)</th>
</tr>
</thead>
<tbody><tr>
<td>最优时间复杂度</td>
<td>O(n)</td>
</tr>
<tr>
<td>平均时间复杂度</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>最差空间复杂度</td>
<td>总共O(n)，需要辅助空间O(1)</td>
</tr>
</tbody></table>
<p><strong>3）算法代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BubbleSort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    n =len(nums)</span><br><span class="line">    <span class="keyword">while</span> n&gt;<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt;nums[j+<span class="number">1</span>]:</span><br><span class="line">                nums[j], nums[j+<span class="number">1</span>] =nums[j+<span class="number">1</span>], nums[j]</span><br><span class="line">        n -=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>

<h5 id="六、鸡尾酒排序-双向冒泡排序"><a href="#六、鸡尾酒排序-双向冒泡排序" class="headerlink" title="六、鸡尾酒排序/双向冒泡排序"></a>六、鸡尾酒排序/双向冒泡排序</h5><p><strong>1）算法简介</strong></p>
<p>鸡尾酒排序等于是冒泡排序的轻微变形，不同的地方在于从低到高然后从高到低，而冒泡排序则仅从低到高去比较序列里的每个元素。它可以得到比冒泡排序稍微好一点的效能，原因是冒泡排序只从一个方向进行比对（由低到高），每次循环时只移动一个项目。</p>
<p><strong>2）算法描述</strong></p>
<ol>
<li>依次比较相邻的两个数，将小数放在前面，大数放在后面</li>
<li>第一趟可得到：将最大数放到最后一位</li>
<li>第二趟可得到：将第二大的数放到倒数第二位</li>
<li>如此下去，重复以上过程，直至最终完成排序</li>
</ol>
<p>鸡尾酒排序最糟或是平均所花费的次数都是O(n^2)，但是如果序列在一开始已经大部分排序过的话，会接近O(n)。</p>
<table>
<thead>
<tr>
<th>最差时间复杂度</th>
<th>O(n^2)</th>
</tr>
</thead>
<tbody><tr>
<td>最优时间复杂度</td>
<td>O(n)</td>
</tr>
<tr>
<td>平均时间复杂度</td>
<td>O(n^2)</td>
</tr>
</tbody></table>
<p><strong>3）算法代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CoktailSort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    n =len(nums)<span class="number">-1</span></span><br><span class="line">    i =<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i&lt;n:</span><br><span class="line">        <span class="comment">#将最小的数排到前面</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n, i, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &lt;nums[j<span class="number">-1</span>]:</span><br><span class="line">                nums[j], nums[j<span class="number">-1</span>] =nums[j<span class="number">-1</span>], nums[j]</span><br><span class="line">        i +=<span class="number">1</span></span><br><span class="line">        <span class="comment">#将最大的数排到后面</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, n):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt;nums[j+<span class="number">1</span>]:</span><br><span class="line">                nums[j], nums[j+<span class="number">1</span>] =nums[j+<span class="number">1</span>], nums[j]</span><br><span class="line">        n -=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>

<h5 id="七、快速排序"><a href="#七、快速排序" class="headerlink" title="七、快速排序"></a>七、快速排序</h5><p><strong>1）算法简介</strong></p>
<p>快速排序是由东尼 霍尔所发展的一种排序算法，其基本思想是，通过一趟排序将待排记录分隔成独立两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
<p><strong>2）算法描述</strong></p>
<p>快速排序使用分治法来把一个串分为两个子串：</p>
<ol>
<li>从数列中挑出一个元素，称为基准(pivot)</li>
<li>重新排列数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列中间位置。这个称为分区(partition)操作。</li>
<li>递归的把小于基准值元素的子数列和大于基准值元素的子数列排序</li>
</ol>
<p>递归到最底部情形是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次迭代中，它至少会把一个元素摆到它最后的位置去。</p>
<p>在平均状况下，排序n个项目要O(nlogn)次比较，在最坏状况下则需要O(n^2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其它O(nlogn)算法更快，因为它的内部循环可以在大部分的架构上很有效率的被实现出来。</p>
<table>
<thead>
<tr>
<th>最差时间复杂度</th>
<th>O(n^2)</th>
</tr>
</thead>
<tbody><tr>
<td>最优时间复杂度</td>
<td>O(nlogn)</td>
</tr>
<tr>
<td>平均时间复杂度</td>
<td>O(nlogn)</td>
</tr>
<tr>
<td>最差空间复杂度</td>
<td>根据实现的方式不同而不同</td>
</tr>
</tbody></table>
<p><strong>3）算法代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">QuickSort</span><span class="params">(nums, left, right)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> left &lt;right:</span><br><span class="line">        i, j =left, right</span><br><span class="line">        <span class="comment">#准备以本次最左边的元素值为标准进行划分，先保存其值</span></span><br><span class="line">        pivot =nums[left]</span><br><span class="line">        <span class="keyword">while</span> i !=j:</span><br><span class="line">            <span class="comment">#从右向左找第1个小于标准值的位置j</span></span><br><span class="line">            <span class="keyword">while</span> nums[j] &gt;pivot <span class="keyword">and</span> i &lt;j:</span><br><span class="line">                j -=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i &lt;j:</span><br><span class="line">                nums[i] =nums[j] <span class="comment">#将第j个元素置于左端并重置i</span></span><br><span class="line">                i +=<span class="number">1</span></span><br><span class="line">            <span class="comment">#从左向右找第1个大于标准值的位置i</span></span><br><span class="line">            <span class="keyword">while</span> nums[i] &lt;pivot <span class="keyword">and</span> i &lt;j:</span><br><span class="line">                i +=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i &lt;j:</span><br><span class="line">                nums[j] =nums[i]</span><br><span class="line">                j -=<span class="number">1</span></span><br><span class="line">        nums[i] =pivot</span><br><span class="line">        QuickSort(nums, left, i<span class="number">-1</span>)</span><br><span class="line">        QuickSort(nums, i+<span class="number">1</span>, right)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>

<h5 id="八、堆排序"><a href="#八、堆排序" class="headerlink" title="八、堆排序"></a>八、堆排序</h5><p><strong>1）算法简介</strong></p>
<p>堆排序是指利用堆这种数据结构所设计的一种排序算法，堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子节点的键值或索引总是小于或大于它的父节点。</p>
<p><strong>2）算法描述</strong></p>
<ol>
<li><p>什么是堆？</p>
<p>我们这里提到的堆一般都指的是二叉堆，它满足二个特性：</p>
<ul>
<li>父节点的键值总是大于或等于（小于或等于）任何一个子节点的键值</li>
<li>每个父节点的左子树和右子树都是一个二叉堆（都是最大堆或最小堆）</li>
</ul>
</li>
<li><p>什么是堆调整？</p>
<p>这是为了保持堆的特性而做的一个操作。堆某一个节点为根的子树做堆调整，其实就是将该根节点进行“下沉”操作，一直下沉到合适的位置，使得刚才的子树满足堆的性质。</p>
<p>例如，对最大堆的堆调整会这么做：</p>
<ul>
<li>在对应的数组元素A[i]，左孩子A[left(i)]，和右孩子A[right(i)]中找到最大的那一个，将其下标存储在largest中</li>
<li>如果A[i]已经就是最大的元素，则程序直接结束</li>
<li>否则，i的某个子节点为最大的元素，将A[largest]与A[i]交换</li>
<li>再从交换的子节点开始，重复1，2，3步，直至叶子节点，算完成一次堆调整</li>
</ul>
<p>这里需要提一下的是，一般做一次堆调整的时间复杂度为log(n)。</p>
</li>
<li><p>如何建堆？</p>
<p>建堆是一个通过不断堆调整，使得整个二叉树中的数满足堆性质的操作。在数组中的话，我们一般从下标为n/2的数开始做堆调整，一直到下标为0的数（因为下标大于n/2的数都是叶子节点，其子树已经满足堆的性质了）</p>
</li>
<li><p>如何进行堆排序？</p>
<p>堆排序是在上述3中对数组建堆的操作之后完成的。数组存储成堆的形式之后，第一次将A[0]与A[n-1]交换，再对A[0…n-2]重新恢复堆。第二次将A[0]与A[n-2]交换，再对A[0…n-3]重新恢复堆，重复这样的操作直到A[0]与A[1]交换。由于每次都是将最小的数据并入到后面的有序区间，故操作完成后整个数组就有序了。</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>最差时间复杂度</th>
<th>O(nlogn)</th>
</tr>
</thead>
<tbody><tr>
<td>最优时间复杂度</td>
<td>O(nlogn)</td>
</tr>
<tr>
<td>平均时间复杂度</td>
<td>O(nlogn)</td>
</tr>
<tr>
<td>最差空间复杂度</td>
<td>O(n)</td>
</tr>
</tbody></table>
<p><strong>3）算法代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapify</span><span class="params">(arr, n, i)</span>:</span></span><br><span class="line">    largest =i</span><br><span class="line">    l =<span class="number">2</span>*i +<span class="number">1</span></span><br><span class="line">    r =<span class="number">2</span>*i +<span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> l &lt;n <span class="keyword">and</span> arr[i] &lt;arr[l]:</span><br><span class="line">        largest =l</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> r &lt;n <span class="keyword">and</span> arr[largest] &lt;arr[r]:</span><br><span class="line">        largest =r</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> largest != i:</span><br><span class="line">        arr[i], arr[largest] =arr[largest], arr[i]</span><br><span class="line">        heapify(arr, n, largest)</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    n =len(arr)</span><br><span class="line">    <span class="comment">#构造大顶堆</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        heapify(arr, n, i)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">#一个个交换元素</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        arr[i], arr[<span class="number">0</span>] =arr[<span class="number">0</span>], arr[i]</span><br><span class="line">        heapify(arr, i, <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>

<h5 id="九、归并排序"><a href="#九、归并排序" class="headerlink" title="九、归并排序"></a>九、归并排序</h5><p><strong>1）算法简介</strong></p>
<p>归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用分治法的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段件有序。若将两个有序表合并成一个有序表，称为2-路归并。</p>
<p><strong>2）算法描述</strong></p>
<ol>
<li>Divide：把长度为n的输入序列分成两个长度为n/2的子序列</li>
<li>Conquer：对这两个子序列分别采用归并排序</li>
<li>Combine：将两个排序好的子序列合并成一个最终的排序序列</li>
</ol>
<p>归并排序的效率是比较高的，设数列长度为n，将数列分开成小数列一共要logn步，每步都是一个合并有序数列的过程，时间复杂度可以记为O(n)，故一共为O(nlogn)。因为归并排序每次都是在相邻的数据中进行操作，所以归并排序在O(nlogn)的几种排序方法（快速排序，归并排序，希尔排序，堆排序）也是效率比较高的。</p>
<p><strong>3）算法代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergesort</span><span class="params">(seq)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(seq) &lt;=<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> seq</span><br><span class="line">    mid =len(seq)//<span class="number">2</span></span><br><span class="line">    <span class="comment">#分别对左右两个列表进行处理，分别返回两个排序好的列表</span></span><br><span class="line">    left =mergesort(seq[:mid])</span><br><span class="line">    right =mergesort(seq[mid:])</span><br><span class="line">    <span class="comment">#对排序好的列表合并，产生一个新的排序好的列表</span></span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br><span class="line">           </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left, right)</span>:</span></span><br><span class="line">    <span class="comment">#合并两个已排序好的列表，产生一个新的已排序号列表</span></span><br><span class="line">    res =[]</span><br><span class="line">    i =<span class="number">0</span></span><br><span class="line">    j =<span class="number">0</span></span><br><span class="line">    <span class="comment">#对两个列表中的元素两两对比</span></span><br><span class="line">    <span class="comment">#将最小的元素，放到res中，并对当前列表下标加1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;len(left) <span class="keyword">and</span> j &lt;len(right):</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt; right[j]:</span><br><span class="line">            res.append(left[i])</span><br><span class="line">            i +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append(right[j])</span><br><span class="line">            j +=<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">    res +=left[i:]</span><br><span class="line">    res +=right[j:]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h5 id="十、桶排序"><a href="#十、桶排序" class="headerlink" title="十、桶排序"></a>十、桶排序</h5><p><strong>1）算法简介</strong></p>
<p>桶排序（Bucket sort）或所谓的箱排序，工作原理是将数组分到有限数量的桶子里，每个桶子再个别排序（有可能使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是稳定的，且在大多数情况下常见排序里最快的一种，比快排还要快，缺点是非常耗空间，基本上是最耗空间的一种排序算法，而且只能在某些情形下使用。</p>
<p><strong>2）算法描述</strong></p>
<ol>
<li>设置一个定量的数组当作空桶子</li>
<li>寻访串行，并且把项目一个一个放到对应的桶子里</li>
<li>对每个不是空的桶子进行排序</li>
<li>从不是空的桶子里把项目放回原来的串行中</li>
</ol>
<p>桶排序最好情况下使用线性时间O(n)，很显然桶排序的时间复杂度，取决于对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)；很显然，桶划分的越大，各个桶之间的数据越少，排序所用的时间也会越小，但相应的空间消耗就会增大。可以证明，即使选用插入排序作为桶内排序的方法，桶排序的平均时间复杂度为线性。</p>
<p><strong>3）算法代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bucket_sort</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="comment">#初始化桶元素为0</span></span><br><span class="line">    buckets =[<span class="number">0</span>] *(max(a) -min(a) +<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span>  i <span class="keyword">in</span> range(len(a)):</span><br><span class="line">        <span class="comment">#遍历数组a，在桶的相应位置累加值</span></span><br><span class="line">        buckets[a[i] -min(a)] +=<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    b =[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(buckets)):</span><br><span class="line">        <span class="keyword">if</span> buckets[i] !=<span class="number">0</span>:</span><br><span class="line">            b +=[i+min(a)]*buckets[i]</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure>

<h5 id="十一、计数排序"><a href="#十一、计数排序" class="headerlink" title="十一、计数排序"></a>十一、计数排序</h5><p><strong>1）算法简介</strong></p>
<p>计数排序是一种稳定的排序算法，计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数，然后根据数组C来将A中的元素排到正确的位置，它只能对整数进行排序。</p>
<p><strong>2）算法描述</strong></p>
<ol>
<li>找出待排序的数组最大和最小的元素</li>
<li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项</li>
<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</li>
<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</li>
</ol>
<p>当输入的元素是n个0到k之间的整数时，它的运行时间是O(n+k)，计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。</p>
<p><strong>3）算法代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_sort</span><span class="params">(a, k)</span>:</span> <span class="comment">#k =max(a)</span></span><br><span class="line">    n =len(a)</span><br><span class="line">    b =[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)] <span class="comment">#设置输出序列并初始化为0</span></span><br><span class="line">    c =[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(k+<span class="number">1</span>)] <span class="comment">#设置计数序列并初始化为0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> a:</span><br><span class="line">        c[j] =c[j] +<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(c)):</span><br><span class="line">        c [i] =c[i] +c[i<span class="number">-1</span>]</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> a:</span><br><span class="line">        b[c[j] <span class="number">-1</span>] =j</span><br><span class="line">        c[j] =c[j] <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure>

<h5 id="十二、基数排序"><a href="#十二、基数排序" class="headerlink" title="十二、基数排序"></a>十二、基数排序</h5><p><strong>1）算法简介</strong></p>
<p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>
<p><strong>2）算法描述</strong></p>
<ol>
<li>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零</li>
<li>从最低位开始，依次进行一次排序</li>
<li>这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列</li>
</ol>
<p>基数排序的时间复杂度是O(kn)，其中n是排序元素个数，k是数字位数</p>
<p><strong>3）算法代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">radix_sort</span><span class="params">(list, d=<span class="number">3</span>)</span>:</span> <span class="comment">#默认三位数，如果是四位数，则d=4，以此类推</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(d): <span class="comment">#d轮排序</span></span><br><span class="line">        s =[[] <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">10</span>)]   <span class="comment">#因每一位数字都是0-9，建10个桶</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> list:</span><br><span class="line">            s[int(j/(<span class="number">10</span>**i))%<span class="number">10</span>].append(j)</span><br><span class="line">        re =[a <span class="keyword">for</span> b <span class="keyword">in</span> s <span class="keyword">for</span> a <span class="keyword">in</span> b]</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> re</span><br></pre></td></tr></table></figure>

<h4 id="更多精彩，关注“咋家”"><a href="#更多精彩，关注“咋家”" class="headerlink" title="更多精彩，关注“咋家”"></a>更多精彩，关注“咋家”</h4><p><img src="http://ww1.sinaimg.cn/large/005xDMfSly1g491vnwsy7j30bi06976v.jpg" alt></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/python/" rel="tag"># python</a>
          
            <a href="/tags/排序算法/" rel="tag"># 排序算法</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/07/28/刷题34——面试题63：股票的最大利润/" rel="next" title="刷题34——面试题63：股票的最大利润">
                <i class="fa fa-chevron-left"></i> 刷题34——面试题63：股票的最大利润
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/07/30/常用数据库SQL操作总结/" rel="prev" title="常用数据库SQL操作总结">
                常用数据库SQL操作总结 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/author.jpg" alt="廿十">
            
              <p class="site-author-name" itemprop="name">廿十</p>
              <p class="site-description motion-element" itemprop="description">Stay hungry, Stay foolish</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">52</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/CSC1994" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:cschang1994@foxmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-5"><a class="nav-link" href="#一、插入排序"><span class="nav-number">1.</span> <span class="nav-text">一、插入排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#二、二分插入排序"><span class="nav-number">2.</span> <span class="nav-text">二、二分插入排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#三、希尔排序"><span class="nav-number">3.</span> <span class="nav-text">三、希尔排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#四、选择排序"><span class="nav-number">4.</span> <span class="nav-text">四、选择排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#五、冒泡排序"><span class="nav-number">5.</span> <span class="nav-text">五、冒泡排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#六、鸡尾酒排序-双向冒泡排序"><span class="nav-number">6.</span> <span class="nav-text">六、鸡尾酒排序/双向冒泡排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#七、快速排序"><span class="nav-number">7.</span> <span class="nav-text">七、快速排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#八、堆排序"><span class="nav-number">8.</span> <span class="nav-text">八、堆排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#九、归并排序"><span class="nav-number">9.</span> <span class="nav-text">九、归并排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#十、桶排序"><span class="nav-number">10.</span> <span class="nav-text">十、桶排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#十一、计数排序"><span class="nav-number">11.</span> <span class="nav-text">十一、计数排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#十二、基数排序"><span class="nav-number">12.</span> <span class="nav-text">十二、基数排序</span></a></li></ol><li class="nav-item nav-level-4"><a class="nav-link" href="#更多精彩，关注“咋家”"><span class="nav-number"></span> <span class="nav-text">更多精彩，关注“咋家”</span></a></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">廿十</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
